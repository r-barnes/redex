"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[141],{3905:function(e,n,a){a.r(n),a.d(n,{MDXContext:function(){return d},MDXProvider:function(){return c},mdx:function(){return f},useMDXComponents:function(){return p},withMDXComponents:function(){return m}});var t=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function s(){return s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},s.apply(this,arguments)}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},s=Object.keys(e);for(t=0;t<s.length;t++)a=s[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)a=s[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,s({},n,{components:a}))}},p=function(e){var n=t.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},c=function(e){var n=p(e.components);return t.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=p(a),c=i,h=m["".concat(l,".").concat(c)]||m[c]||u[c]||s;return a?t.createElement(h,o(o({ref:n},d),{},{components:a})):t.createElement(h,o({ref:n},d))}));function f(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=a.length,l=new Array(s);l[0]=h;var o={};for(var r in n)hasOwnProperty.call(n,r)&&(o[r]=n[r]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var d=2;d<s;d++)l[d]=a[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},99382:function(e,n,a){a.r(n),a.d(n,{assets:function(){return m},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return p}});var t=a(83117),i=a(80102),s=(a(67294),a(3905)),l=["components"],o={id:"passes",title:"Passes",sidebar_position:3},r=void 0,d={unversionedId:"getting_started/passes",id:"getting_started/passes",title:"Passes",description:"ReDex has a large set of optimization passes that is constantly evolving.",source:"@site/docs/getting_started/passes.md",sourceDirName:"getting_started",slug:"/getting_started/passes",permalink:"/docs/getting_started/passes",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"passes",title:"Passes",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Configuring ReDex",permalink:"/docs/getting_started/configuring"},next:{title:"Usage",permalink:"/docs/getting_started/usage"}},m={},p=[{value:"AccessMarkingPass",id:"accessmarkingpass",level:2},{value:"AnnoKillPass",id:"annokillpass",level:2},{value:"BridgeSynthInlinePass",id:"bridgesynthinlinepass",level:2},{value:"CheckBreadcrumbsPass",id:"checkbreadcrumbspass",level:2},{value:"ClassMergingPass",id:"classmergingpass",level:2},{value:"ConstantPropagationPass",id:"constantpropagationpass",level:2},{value:"CopyPropagationPass",id:"copypropagationpass",level:2},{value:"DedupBlocksPass",id:"dedupblockspass",level:2},{value:"DelSuperPass",id:"delsuperpass",level:2},{value:"FinalInlinePassV2",id:"finalinlinepassv2",level:2},{value:"LocalDcePass",id:"localdcepass",level:2},{value:"MethodDevirtualizationPass",id:"methoddevirtualizationpass",level:2},{value:"ObfuscatePass",id:"obfuscatepass",level:2},{value:"OptimizeEnumsPass",id:"optimizeenumspass",level:2},{value:"OriginalNamePass",id:"originalnamepass",level:2},{value:"PeepholePass",id:"peepholepass",level:2},{value:"ReBindRefsPass",id:"rebindrefspass",level:2},{value:"ReduceGotosPass",id:"reducegotospass",level:2},{value:"RegAllocPass",id:"regallocpass",level:2},{value:"RemoveBuildersPass",id:"removebuilderspass",level:2},{value:"RemoveInterfacePass",id:"removeinterfacepass",level:2},{value:"RemoveUnreachablePass",id:"removeunreachablepass",level:2},{value:"RemoveUnusedFieldsPass",id:"removeunusedfieldspass",level:2},{value:"RemoveUnusedArgsPass",id:"removeunusedargspass",level:2},{value:"RenameClassesPassV2",id:"renameclassespassv2",level:2},{value:"ReorderInterfacesDeclPass",id:"reorderinterfacesdeclpass",level:2},{value:"ResultPropagationPass",id:"resultpropagationpass",level:2},{value:"ShortenSrcStringsPass",id:"shortensrcstringspass",level:2},{value:"MethodInlinePass",id:"methodinlinepass",level:2},{value:"SingleImplPass",id:"singleimplpass",level:2},{value:"StaticReloPassV2",id:"staticrelopassv2",level:2},{value:"StringConcatenatorPass",id:"stringconcatenatorpass",level:2},{value:"StripDebugInfoPass",id:"stripdebuginfopass",level:2}],c={toc:p};function u(e){var n=e.components,a=(0,i.Z)(e,l);return(0,s.mdx)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"ReDex has a large set of optimization passes that is constantly evolving.\nInformation in this document may be outdated, inspect the code if necessary."),(0,s.mdx)("h2",{id:"accessmarkingpass"},"AccessMarkingPass"),(0,s.mdx)("p",null,"Final objects and private methods can be optimized more aggressively than\nvirtual objects and public methods."),(0,s.mdx)("p",null,"Devirtualization can result in ","[NullPointerException]",". Two Redex passes perform\ndevirtualization of methods: ",(0,s.mdx)("inlineCode",{parentName:"p"},"AccessMarkingPass")," devirtualizes methods not using\n",(0,s.mdx)("inlineCode",{parentName:"p"},"this"),". ",(0,s.mdx)("a",{parentName:"p",href:"#methodinlinepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"MethodInlinePass"))," inlines monomorphic virtual\ncalls."),(0,s.mdx)("p",null,"The ",(0,s.mdx)("a",{parentName:"p",href:"/docs/getting_started/configuring"},"app's config file")," can override ",(0,s.mdx)("inlineCode",{parentName:"p"},"AccessMarkingPass")," behavior.\n",(0,s.mdx)("inlineCode",{parentName:"p"},"finalize_methods"),", ",(0,s.mdx)("inlineCode",{parentName:"p"},"finalize_unwritten_fields"),", ",(0,s.mdx)("inlineCode",{parentName:"p"},"finalize_classes"),", and\n",(0,s.mdx)("inlineCode",{parentName:"p"},"privatize_methods")," default to ",(0,s.mdx)("inlineCode",{parentName:"p"},"true"),". ",(0,s.mdx)("inlineCode",{parentName:"p"},"finalize_written_fields")," defaults to ",(0,s.mdx)("inlineCode",{parentName:"p"},"false"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},'"AccessMarkingPass": {\n  "finalize_written_fields": true\n},\n')),(0,s.mdx)("p",null,"Pass ordering dependencies:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"AccessMarkingPass")," should be run early as it enables other optimizations.")),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#methoddevirtualizationpass"},(0,s.mdx)("inlineCode",{parentName:"a"},"MethodDevirtualizationPass")))),(0,s.mdx)("h2",{id:"annokillpass"},"AnnoKillPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"AnnoKillPass"),' originally removed only annotations with no static references in\nthe code--"build-visible" annotations. It was expanded to remove annotations\nreferenced statically, but not used at runtime--"runtime-visible" annotations.'),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"AnnoKillPass")," reads configuration options from the ",(0,s.mdx)("a",{parentName:"p",href:"/docs/getting_started/configuring"},"app's config\nfile")," specifying annotations to be kept or killed. An additional\noption specifies whether Redex should attempt to match signatures for removal."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},'"AnnoKillPass" : {\n  "keep_annos": [\n    "Landroid/view/ViewDebug$CapturedViewProperty;",\n    "Landroid/view/ViewDebug$ExportedProperty;"\n  ],\n  "kill_bad_signatures" : true,\n  "kill_annos" : [\n    "Lcom/google/inject/BindingAnnotation;"\n  ]\n},\n')),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#systemannokillpass"},(0,s.mdx)("inlineCode",{parentName:"a"},"SystemAnnoKillPass")))),(0,s.mdx)("h2",{id:"bridgesynthinlinepass"},"BridgeSynthInlinePass"),(0,s.mdx)("p",null,"As the name suggests BridgeSynthInlinePass removes bridge and synthetic methods by inlining them."),(0,s.mdx)("p",null,"Bridge methods are created by the ",(0,s.mdx)("inlineCode",{parentName:"p"},"javac")," compiler as part of\ntype erasure for covariant generics."),(0,s.mdx)("p",null,"Example of a bridge method in pseudo-bytecode:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},"check-cast*   (for checking covariant arg types)\ninvoke-{direct,virtual,static}  bridged-method\nmove-result\nreturn\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"BridgeSynthInlinePass"),' inlines the target of the bridging, the "bridgee", into the bridge\nmethod by replacing the ',(0,s.mdx)("inlineCode",{parentName:"p"},"invoke-")," and adjusting check-casts as needed. The\nbridgee can then be deleted."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"BridgeSynthInlinePass")," also removes synthetic methods introduced by ",(0,s.mdx)("inlineCode",{parentName:"p"},"javac"),". ",(0,s.mdx)("inlineCode",{parentName:"p"},"javac")," generates\nthese methods because while Java allows inner classes or nested classes, DEX\nbytecode does not. Inner classes, like ",(0,s.mdx)("inlineCode",{parentName:"p"},"class Delta")," in this example, are\npromoted to top-level classes in the DEX bytecode."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"public class Gamma {\n    public Gamma(int v) {\n        x = v;\n    }\n    private int x;\n\n    public class Delta {\n        public int doublex() {\n            return 2*x;\n        }\n    }\n}\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"javac")," generates a synthetic method that allows access to fields, methods, and\nconstructors in the promoted class. ",(0,s.mdx)("inlineCode",{parentName:"p"},"SynthPass")," effectively removes these synthetic methods,\nreplacing them with a direct access to the field or call to the method or\nconstructor."),(0,s.mdx)("p",null,"The general limitations and the cost model of the inliner applies. As a result, some bridge and synthetic method inlining opportunities might not be acted upon, e.g. when it would result in API-level violations, or an overall size increase."),(0,s.mdx)("h2",{id:"checkbreadcrumbspass"},"CheckBreadcrumbsPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"CheckBreadcrumbsPass")," validates Redex codegen against leftover references to\ndeleted types, methods, or fields."),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"Verifies that there are no references to a deleted class definition remaining\nin DEX files (essentially an ",(0,s.mdx)("inlineCode",{parentName:"li"},"internal")," class that is not in scope)."),(0,s.mdx)("li",{parentName:"ul"},"Verifies that the target of a field and method reference exists on the class\nit is defined on.")),(0,s.mdx)("p",null,"Redex will warn if it finds dangling references or illegal references to\nentities."),(0,s.mdx)("h2",{id:"classmergingpass"},"ClassMergingPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"ClassMergingPass")," shrinks the size of code generated by some frameworks. These\ntools produce large amounts of Java code for each component. The code generated\nfor different component types often shares the same structure, differing only by\nthe type of the component."),(0,s.mdx)("p",null,'Class Merging identifies pieces of generated code that have the same "shape".\nErasing the types that differ allows the pieces of generated code to be merged.'),(0,s.mdx)("h2",{id:"constantpropagationpass"},"ConstantPropagationPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"ConstantPropagationPass")," substitutes the values of constants into expressions\nat compile time. Constant propagation can eliminate multiple expressions,\nresulting in a constant load."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"ConstantPropagationPass")," does a whole program analysis to replace instructions\nwith single destination registers with constant loads. The analysis is run\niteratively until a fixed point or configurable limit is reached."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"CostantPropagationPass")," should be run before dead code elimination (DCE) passes\nas it can create dead code."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#localdcepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"LocalDCEPass"))),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#removeunreachablepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"RemoveUnreachablePass")))),(0,s.mdx)("h2",{id:"copypropagationpass"},"CopyPropagationPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"CopyPropagationPass")," removes writes of duplicated values to registers in a\nbasic block. If value ",(0,s.mdx)("inlineCode",{parentName:"p"},"A")," and value ",(0,s.mdx)("inlineCode",{parentName:"p"},"B")," are aliases, then any moves between\nthese registers are unnecessary and can be eliminated. Duplicated source\nregisters can also be deduplicated."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"CopyPropagationPass")," can also remove duplicated instructions if the source and\nthe destination are aliased."),(0,s.mdx)("p",null,"Example: ",(0,s.mdx)("inlineCode",{parentName:"p"},"v0")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"v1")," contain the same value and can be treated locally as\naliases:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},"const v0, 0\nconst v1, 0\ninvoke-static v0 foo\ninvoke-static v1 bar\n")),(0,s.mdx)("p",null,"can be transformed into"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},"const v0, 0\ninvoke-static v0 foo\ninvoke-static v0 bar\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"CopyPropagationPass")," should be run before dead code elimination (DCE) passes as\nit can create dead code."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#localdcepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"LocalDCEPass"))),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#removeunreachablepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"RemoveUnreachablePass")))),(0,s.mdx)("h2",{id:"dedupblockspass"},"DedupBlocksPass"),(0,s.mdx)("p",null,"Dedup blocks inside of a method. Duplicated blocks are those with the same code\nand the same successor. Duplicated blocks can have different predecessors."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"DedupBlocksPass")," identifies one of the blocks as the canonical version, then\nredirects all predecessors to the canonical block. The pass currenly only\nidentifies blocks with a single successor, but in the future may identify blocks\nwith multiple sucessors."),(0,s.mdx)("p",null,"Stack traces for deduplicated blocks will always report the same line number,\nbut the predecessor line numbers will be correct."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"DedupBlocksPass")," should be run after ",(0,s.mdx)("a",{parentName:"p",href:"#interdexpass"},(0,s.mdx)("inlineCode",{parentName:"a"},"InterDexPass")),"."),(0,s.mdx)("h2",{id:"delsuperpass"},"DelSuperPass"),(0,s.mdx)("p",null,"DelSuperPass eliminates subclass methods that invoke the superclass method and\ntrivially return."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"DelSuperPass")," only optimizes virtual methods with the following\ncharacteristics:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"The subclass method must match the name and signature of the superclass method"),(0,s.mdx)("li",{parentName:"ul"},"The subclass method must only invoke the superclass method and either return\n",(0,s.mdx)("inlineCode",{parentName:"li"},"void")," or the result of the callee.")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"DelSuperPass")," also fixes up references to the removed subclass methods, making\nthem refer to the superclass method instead. Though ",(0,s.mdx)("a",{parentName:"p",href:"https://source.android.com/devices/tech/dalvik/dalvik-bytecode"},"Dalvik's\n",(0,s.mdx)("inlineCode",{parentName:"a"},"invoke-virtual")),"\nwould automatically resolve to the correct superclass method, doing this reduces\nthe number of method references in the Dex file and saves on space."),(0,s.mdx)("h2",{id:"finalinlinepassv2"},"FinalInlinePassV2"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"FinalInlinePassV2"),", or an instance field's value after ",(0,s.mdx)("inlineCode",{parentName:"p"},"<init>"),", and inlines\nthe value in dex code. Note that this pass is separate from the ",(0,s.mdx)("inlineCode",{parentName:"p"},"MethodInline"),"\nand ",(0,s.mdx)("inlineCode",{parentName:"p"},"SwitchInline")," passes."),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"DX")," tool often introduces verbose bytecode sequences to initialize static\nfields in classes it generates. The ",(0,s.mdx)("inlineCode",{parentName:"p"},"encoded_value")," equivalents are much more\ncompact. This pass determines the values of static fields after ",(0,s.mdx)("inlineCode",{parentName:"p"},"<clinit>")," and\neliminates the redundant writes to the static field."),(0,s.mdx)("p",null,"This pass applies to both final and non-final static fields. For final statics\nit also inlines reads of the static field where possible, replacing them with\nconstant operations outside of ",(0,s.mdx)("inlineCode",{parentName:"p"},"<clinit>"),"."),(0,s.mdx)("p",null,"For instance fields, the pass calculates the field's value after ",(0,s.mdx)("inlineCode",{parentName:"p"},"<init>")," is\nfinished. It inlines reads of the instance field where possible."),(0,s.mdx)("p",null,"Unlike a static field, if an instance field were changed outside of ",(0,s.mdx)("inlineCode",{parentName:"p"},"<init>"),", it\nmight have different values for different instances of the class. For classes\nwith multiple ",(0,s.mdx)("inlineCode",{parentName:"p"},"<init>")," the instance field values might differ based on the\nconstructor. This pass does not inline instance fields that are:"),(0,s.mdx)("ol",null,(0,s.mdx)("li",{parentName:"ol"},"Modified outside of their class ",(0,s.mdx)("inlineCode",{parentName:"li"},"<init>"),"."),(0,s.mdx)("li",{parentName:"ol"},"In a class that have more than one constructor."),(0,s.mdx)("li",{parentName:"ol"},"Accessed by reflection or native code anywhere in code."),(0,s.mdx)("li",{parentName:"ol"},"Accessed in another method that is called inside of the constructor.")),(0,s.mdx)("p",null,"Note that this pass does not inline the ",(0,s.mdx)("inlineCode",{parentName:"p"},"CharSequence")," type for static or\ninstance fields because older Dalvik VMs cannot handle this class."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#methodinlinepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"MethodInlinePass")))),(0,s.mdx)("h2",{id:"localdcepass"},"LocalDcePass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"LocalDcePass")," removes dead instructions in a method. Code is considered to be\n\"dead' if it has no side-effects and does not change its output registers. Code\nin a ",(0,s.mdx)("inlineCode",{parentName:"p"},"catch")," block is considered live for the duration of the ",(0,s.mdx)("inlineCode",{parentName:"p"},"try"),", as any\ninstruction in the ",(0,s.mdx)("inlineCode",{parentName:"p"},"try")," block is assumed to be able to throw. Methods annotated\nwith ",(0,s.mdx)("inlineCode",{parentName:"p"},"@DoNotOptimize")," are not considered for dead code elimination."),(0,s.mdx)("p",null,"Dead code elimination (DCE) differs from RemoveUnreachable (RMU) in two ways:\nfirst, RMU works from global roots (at the scope of Class/Method/Field) whereas\nDCE works at the function scope. Second, DCE removes code that does not change\nstate, for example, a store to a memory address that is not read in the scope of\nthe block, whereas RMU removes code that is unreachable regardless of its effect\non state."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#removeunreachablepass"},"RemoveUnreachablePass"))),(0,s.mdx)("h2",{id:"methoddevirtualizationpass"},"MethodDevirtualizationPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"MethodDevirtualizationPass")," converts virtual methods with single\nimplementation to static dmethods."),(0,s.mdx)("p",null,"The ",(0,s.mdx)("a",{parentName:"p",href:"/docs/getting_started/configuring"},"app's config file"),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},'"MethodDevirtualizationPass" : {\n  "staticize_vmethods_not_using_this" : true,\n  "staticize_dmethods_not_using_this" : true\n},\n')),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#accessmarkingpass"},(0,s.mdx)("inlineCode",{parentName:"a"},"AccessMarkingPass")))),(0,s.mdx)("h2",{id:"obfuscatepass"},"ObfuscatePass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"ObfuscatePass")," pass obfuscates method and field names. ",(0,s.mdx)("inlineCode",{parentName:"p"},"RenameClassesPassV2"),"\nobfuscates class names."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#renameclassespassv2"},(0,s.mdx)("inlineCode",{parentName:"a"},"RenameClassesPassV2")))),(0,s.mdx)("h2",{id:"optimizeenumspass"},"OptimizeEnumsPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"OptimizeEnumsPass")," does two things to make use of ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," classes more\nefficient. It optimizes the use of ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," values in ",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," tables and replaces\nsome uses of ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," values with ",(0,s.mdx)("inlineCode",{parentName:"p"},"Integer")," singletons."),(0,s.mdx)("p",null,"The ",(0,s.mdx)("inlineCode",{parentName:"p"},"javac")," compiler creates ",(0,s.mdx)("a",{parentName:"p",href:"https://source.android.com/devices/tech/dalvik/dalvik-bytecode"},"Dalvik packed\nswitch")," tables\nthat contain a generated anonymous class. ",(0,s.mdx)("inlineCode",{parentName:"p"},"OptimizeEnumPass")," replaces these\npacked ",(0,s.mdx)("inlineCode",{parentName:"p"},"switch")," statements with lookups based on the ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," ordinal itself. Note\nthat this optimization does not work with ProGuard obfuscation enabled. ProGuard\ncan rewrite ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," value names such that they no longer match the ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," class\nname."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"OptimizeEnumsPass")," also replaces some uses of an ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," with a boxed ",(0,s.mdx)("inlineCode",{parentName:"p"},"Integer"),"\nsingleton and keeps the runtime behavior unchanged at the same time."),(0,s.mdx)("p",null,"The pass does not guarantee to erase all the enums, perf sensitive code should\nnever use enums. An ",(0,s.mdx)("inlineCode",{parentName:"p"},"Enum")," is not optimizable if it is:"),(0,s.mdx)("ol",null,(0,s.mdx)("li",{parentName:"ol"},"An abstract ",(0,s.mdx)("inlineCode",{parentName:"li"},"Enum"),"."),(0,s.mdx)("li",{parentName:"ol"},"Reflectively used."),(0,s.mdx)("li",{parentName:"ol"},"Contains an instance field that is not a primitive."),(0,s.mdx)("li",{parentName:"ol"},"Contains non-final instance fields."),(0,s.mdx)("li",{parentName:"ol"},"Cast to any other types, like ",(0,s.mdx)("inlineCode",{parentName:"li"},"java.lang.Object"),", ",(0,s.mdx)("inlineCode",{parentName:"li"},"java.lang.Enum"),",\n",(0,s.mdx)("inlineCode",{parentName:"li"},"java.io.Serializable"),", ",(0,s.mdx)("inlineCode",{parentName:"li"},"java.lang.Comparable"))),(0,s.mdx)("h2",{id:"originalnamepass"},"OriginalNamePass"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},'"OriginalNamePass" : {\n  "hierarchy_roots" : [\n    "Ljava/lang/Runnable;"\n  ]\n},\n')),(0,s.mdx)("p",null,"Redex renames classes for performance reasons. Renaming can result in different\nclass names in debug and release builds, which results in mismatches in logging.\nAlso, some system functions should not be renamed."),(0,s.mdx)("p",null,"An alternative is to use ",(0,s.mdx)("inlineCode",{parentName:"p"},"OriginalClassName.getSimpleName()")," for logging.\n",(0,s.mdx)("inlineCode",{parentName:"p"},"OriginalNamePass")," is preferred as is does not significantly increase the APK\nsize."),(0,s.mdx)("h2",{id:"peepholepass"},"PeepholePass"),(0,s.mdx)("p",null,"Replace small code patterns with a more efficient pattern. The optimization\nmatches known patterns for replacement. It essentially performs a string search\nof the code for known inefficient sequences and replaces them with more\nefficient code. ",(0,s.mdx)("inlineCode",{parentName:"p"},"PeepholePass")," will not replace patterns that span a basic block\nboundary. ",(0,s.mdx)("inlineCode",{parentName:"p"},"PeepholePass")," can remove no-op function calls such as redundant moves\nand appends of null strings."),(0,s.mdx)("p",null,"Peephole pass should be run early."),(0,s.mdx)("h2",{id:"rebindrefspass"},"ReBindRefsPass"),(0,s.mdx)("p",null,"Rebind references to their most abstract type."),(0,s.mdx)("p",null,"The number of methods in a DEX file is limited to 64K. Method definitions (defs)\nand references (refs) both count against this limit. The class scope in an\ninheritance situation can create needless method refs. Calls based on the\nsubclassed methods create unnecessary method refs for the subclass. This is\nespecially true when calls are made through the implicit ",(0,s.mdx)("inlineCode",{parentName:"p"},"this"),"."),(0,s.mdx)("p",null,"For example, you have a class specialized on ",(0,s.mdx)("inlineCode",{parentName:"p"},"<n>")," with a method that calls\n",(0,s.mdx)("inlineCode",{parentName:"p"},"Object.equals(Object)"),". All of these calls create a ref ",(0,s.mdx)("inlineCode",{parentName:"p"},"X<n>.equals(Object)"),",\neach of them counting against the 64K limit. Rebinding them lower in the\nhierarchy reduces the number of unique refs."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"class X<n>\n{\n    public void foo<n>(Object o)\n    {\n        ...\n        if (equals(o) {...}\n        ...\n    }\n}\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"ReBindRefsPass")," rebinds all ",(0,s.mdx)("inlineCode",{parentName:"p"},"invoke-virtual")," to the base def of the virtual\nscope. For ",(0,s.mdx)("inlineCode",{parentName:"p"},"invoke-interface"),", it rebinds to the first interface method def. The\noptimization is only done as long as there is no change in method visibility: we\nwalk down the hiearchy as long as the method is public. ",(0,s.mdx)("inlineCode",{parentName:"p"},"ReBindRefsPass"),"\ndrastically reduces the number of methods defined in DEX files."),(0,s.mdx)("h2",{id:"reducegotospass"},"ReduceGotosPass"),(0,s.mdx)("p",null,"Reduces gotos in two ways:"),(0,s.mdx)("ol",null,(0,s.mdx)("li",{parentName:"ol"},"When a conditional branch would fallthrough to a block that has multiple\nsources, and the branch target only one has one, invert condition and swap\nbranch and goto target. This reduces the need for additional gotos and\nmaximizes the fallthrough efficiency."),(0,s.mdx)("li",{parentName:"ol"},"It replaces gotos that eventually simply return by return instructions.\nReturn instructions tend to have a smaller encoding than goto instructions,\nand tend to compress better due to less entropy (no offset).")),(0,s.mdx)("p",null,"Example, inverting this conditional will eliminate a ",(0,s.mdx)("inlineCode",{parentName:"p"},"goto"),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},"(const v2 0)\n\n(if-eqz v0 :true)\n(:back_jump_target)\n\n(return v2)\n\n(:true)\n(const v2 1)\n(goto :back_jump_target)\n")),(0,s.mdx)("h2",{id:"regallocpass"},"RegAllocPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"RegAllocPass"),' does register allocation: the process of allocating variables\ninto the available physical registers. The goal of register allocation is to\navoid "spilling", that is, moving values from registers into memory.'),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"RegAllocPass")," uses a standard graph-coloring register allocator algorithm,\nknown as the Chaitin-Briggs algorithm."),(0,s.mdx)("h2",{id:"removebuilderspass"},"RemoveBuildersPass"),(0,s.mdx)("p",null,"Remove builder invocations. A trivial builder is one that:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"Doesn't escape the stack (",(0,s.mdx)("inlineCode",{parentName:"li"},"this")," is never passed to a method not in this\ninstance, stored in a field, or returned)"),(0,s.mdx)("li",{parentName:"ul"},"Has no static methods"),(0,s.mdx)("li",{parentName:"ul"},"Has no static fields")),(0,s.mdx)("p",null,"Unreferenced builders are left to be removed by RemoveUnreachablePass (RMU)."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#removeunreachablepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"RemoveUnreachablePass"))),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#resultpropagationpass"},(0,s.mdx)("inlineCode",{parentName:"a"},"ResultPropagationPass")))),(0,s.mdx)("h2",{id:"removeinterfacepass"},"RemoveInterfacePass"),(0,s.mdx)("p",null,"The motivation of this pass is to remove a hierarchy of interfaces extending\neach others. The removal of the interfaces simplifies the type system and\nenables additional type system level optimizations."),(0,s.mdx)("p",null,"We remove each interface by replacing each invoke-interface site with a\ngenerated dispatch stub that models the interface call semantic at bytecode\nlevel. After that we remove the existing references to them from the\nimplementors and remove them completely. We start at the leaf level of the\ninterface hierarchy. After removing the leaf level, we iteratively apply the\nsame transformation to the now newly formed leaf level again and again until all\ninterfaces are removed."),(0,s.mdx)("p",null,"Note that this is a critical pass for optimizing GraphQL generated fragment\nmodels. Aside from the fragment model classes themselves, the GraphQL tool chain\nalso generates a Java interface for each GraphQL fragment namely fragment\ninterface. The existence of these interfaces greatly complicates the type system\nof the generated GraphQL fragment models making merging the underlying model\nclasses virtually impossible. The other interface removal optimizations like\n",(0,s.mdx)("inlineCode",{parentName:"p"},"SingleImpl")," as well as ",(0,s.mdx)("inlineCode",{parentName:"p"},"RemoveUnreachablePass")," can address this issue to some\nextend. But they are not able to remove the majority of them.\n",(0,s.mdx)("inlineCode",{parentName:"p"},"RemoveInterfacePass")," is capable of removing most of the fragment interfaces at\nthe expense of producing the above mentioned dispatch stubs. Doing so before\nClass Merging paves the way for maximizing the code size reduction we can achieve\nin Class Merging."),(0,s.mdx)("h2",{id:"removeunreachablepass"},"RemoveUnreachablePass"),(0,s.mdx)("p",null,"Starting from the roots, recursively mark the other elements that the roots\nreference. Afterwards, it deletes all the unmarked elements."),(0,s.mdx)("p",null,"The pass has various powerful options, including:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"remove_no_argument_constructors"),": Whether to remove argless constructors. They might be used to create instances via reflection, so the default is ",(0,s.mdx)("inlineCode",{parentName:"li"},"false"),"."),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"relaxed_keep_class_members"),': Only consider instance members as roots when their classes are either instantiable, i.e. have a callable constructor, or are "dynamically referenced". A class is "dynamically referenced" if it is mentioned in a Dalvik annotation signature, is referenced in a runtime-visibile annotation, appears in a string or a const-class instruction, is the declaring type of a native method, is present in a native library (lib/',(0,s.mdx)("em",{parentName:"li"},"/"),'.so), has one of the configured "reflected_package_names". The default is ',(0,s.mdx)("inlineCode",{parentName:"li"},"false")," for backwards compatibility."),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"throw_propagation"),": When reachable instructions invoke methods that cannot return (e.g. all possible target methods have no reachable return statement), then subsequent instructions will not be visited, and replaced with a ",(0,s.mdx)("inlineCode",{parentName:"li"},"unreachable")," instruction. The default is ",(0,s.mdx)("inlineCode",{parentName:"li"},"false")," for backwards compatibility."),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"prune_uninstantiable_insns"),": When reachable instructions access instance members of classes that can never be instantiated, then subsequent instructions will not be visited, and replaced with an instruction that throws a ",(0,s.mdx)("inlineCode",{parentName:"li"},"NullPointerException"),". The default is ",(0,s.mdx)("inlineCode",{parentName:"li"},"false")," for backwards compatibility."),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"prune_uncallable_instance_method_bodies"),": When an instance method can never be target of an invocation, even though we might need to keep the method for virtual scope order, or because of keep rules, then we can replace its body with an ",(0,s.mdx)("inlineCode",{parentName:"li"},"unreachable")," instruction. This draws from the same instantiability knowledge that is used for the ",(0,s.mdx)("inlineCode",{parentName:"li"},"prune_uninstantiable_insns")," option. The default is ",(0,s.mdx)("inlineCode",{parentName:"li"},"false")," for backwards compatibility."),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"prune_uncallable_virtual_methods"),": In some cases, we don't need to keep the body of an uncallable method, but instead can make the method abstract, or remove it completely. The default is ",(0,s.mdx)("inlineCode",{parentName:"li"},"false")," for backwards compatibility."),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"prune_unreferenced_interfaces"),": Removes interfaces that are not referenced anywhere in code except in ",(0,s.mdx)("inlineCode",{parentName:"li"},"implements")," clauses. The default is ",(0,s.mdx)("inlineCode",{parentName:"li"},"false")," for backwards compatibility.")),(0,s.mdx)("p",null,"More information about ",(0,s.mdx)("inlineCode",{parentName:"p"},"RemoveUnreachablePass")," is available in this ","[note on\nTeaching Reachability Analysis about Dependency Injection]","."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#localdcepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"LocalDcePass")))),(0,s.mdx)("h2",{id:"removeunusedfieldspass"},"RemoveUnusedFieldsPass"),(0,s.mdx)("p",null,"It's pretty much in the name. A lot of these unread fields are actually\n",(0,s.mdx)("inlineCode",{parentName:"p"},"javac"),"-generated fields for inner classes. Notably, this turns non-static inner\nclasses into static ones where possible."),(0,s.mdx)("p",null,"This pass occasionally causes issues because the app may have been relying on an\nunread field to stop the GC from deleting an object."),(0,s.mdx)("h2",{id:"removeunusedargspass"},"RemoveUnusedArgsPass"),(0,s.mdx)("p",null,"Removes unused parameters. Currently only works on non-virtual methods and\nvirtual methods that are not part of some overriding inheritance hierarchy."),(0,s.mdx)("h2",{id:"renameclassespassv2"},"RenameClassesPassV2"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"RenameClassesPassV2"),' renames classes to shorter names such as "X.A1c", saving\nin APK size, obfuscating the code, and ordering classes to optimize performance\nof loading.'),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"RenameClassesPassV2")," will not rename any class mentioned in resources, nor will\nit rename anything in blocklist either by direct class name or as part of\nan excluded package."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"RenameClassesPassV2")," relies on the ",(0,s.mdx)("a",{parentName:"p",href:"/docs/getting_started/configuring"},"app's config file"),", excluding\nof the class or hierarchy, or use of reflection."),(0,s.mdx)("p",null,"Logview and bug reports are configured to automatically undo this renaming."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#obfuscatepass"},(0,s.mdx)("inlineCode",{parentName:"a"},"ObfuscatePass")))),(0,s.mdx)("h2",{id:"reorderinterfacesdeclpass"},"ReorderInterfacesDeclPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"ReorderInterfacesDeclPass")," list for each class by how frquently the Interfaces\nare called. The Interface list is searched linearly when an Interface is called,\nso calling an Interface at the list will be faster. An alphabetical sort is used\nfor tie-breaks in number of incoming calls to preserve consistency across\nClasses."),(0,s.mdx)("p",null,"This pass could be improved by checking the number of incoming calls\ndynamically."),(0,s.mdx)("h2",{id:"resultpropagationpass"},"ResultPropagationPass"),(0,s.mdx)("p",null,"Refactor code, e.g.,"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"Text.create(context)\n    .clipToBounds(false)\n    .text(myText)\n")),(0,s.mdx)("p",null,"to be as efficient as the less elegant equivalent version:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"Text.Builder b = Text.create(context);\nb.clipToBounds(false)\nb.text(myText)\n")),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#removebuilderspass"},"RemoveBuildersPass"))),(0,s.mdx)("h2",{id:"shortensrcstringspass"},"ShortenSrcStringsPass"),(0,s.mdx)("p",null,"Replaces long filename strings with strings used elsewhere in the APK. This\nmunges the filename component of stack traces. Logview and bug reports\nautomatically reverse this for you."),(0,s.mdx)("h2",{id:"methodinlinepass"},"MethodInlinePass"),(0,s.mdx)("p",null,"For example, in this code, if ",(0,s.mdx)("inlineCode",{parentName:"p"},"run")," is inlined to ",(0,s.mdx)("inlineCode",{parentName:"p"},"main")," and the access of ",(0,s.mdx)("inlineCode",{parentName:"p"},"bar"),"\nthrows, the stack trace in ",(0,s.mdx)("inlineCode",{parentName:"p"},"main")," will show a ",(0,s.mdx)("inlineCode",{parentName:"p"},"NullPointerException")," at the\ndereference of ",(0,s.mdx)("inlineCode",{parentName:"p"},"this")," instead of a call to ",(0,s.mdx)("inlineCode",{parentName:"p"},"run"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"class Foo {\n  private String bar;\n  public void run() {\n    System.out.println(bar);\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Foo foo = null;\n    foo.run();\n  }\n}\n")),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"MethodInlinePass")," will not inline a constructor as the Android verifier checks\nfor a call to ",(0,s.mdx)("inlineCode",{parentName:"p"},"<init>")," before any access to the object."),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"MethodInlinePass")," cannot currently be run after ",(0,s.mdx)("a",{parentName:"p",href:"#interdexpass"},(0,s.mdx)("inlineCode",{parentName:"a"},"InterDexPass")),"."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#finalinlinepassv2"},(0,s.mdx)("inlineCode",{parentName:"a"},"FinalInlinePassV2")))),(0,s.mdx)("h2",{id:"singleimplpass"},"SingleImplPass"),(0,s.mdx)("p",null,"Removes interfaces with only a single implementation. Any classes referring to\nthe interface will now refer to the implementation instead. This can cause minor\nconfusion in stack traces."),(0,s.mdx)("h2",{id:"staticrelopassv2"},"StaticReloPassV2"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"StaticReloPassV2")," relocates static fields and methods that only have one\ncalling class to that class. It improves the performance and reduces the app\nsize."),(0,s.mdx)("p",null,"See related:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"#staticrelopass"},(0,s.mdx)("inlineCode",{parentName:"a"},"StaticReloPass")))),(0,s.mdx)("h2",{id:"stringconcatenatorpass"},"StringConcatenatorPass"),(0,s.mdx)("p",null,"Reduce string operations as well as reducing the number of strings that need\nto be loaded."),(0,s.mdx)("p",null,"Here's an example ",(0,s.mdx)("inlineCode",{parentName:"p"},"<clinit>")," method ",(0,s.mdx)("inlineCode",{parentName:"p"},"StringConcatenationPass")," will optimize:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'public static final String PREFIX = "foo";\npublic static final String CONCATENATED = PREFIX + "bar";\n')),(0,s.mdx)("p",null,"The output code should be equivalent to:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'public static final PREFIX = "foo";\npublic static final CONCATENATED = "foobar";\n')),(0,s.mdx)("p",null,"This is a targeted optimization that is only performed on static initializers\nwith many string concatenations."),(0,s.mdx)("h2",{id:"stripdebuginfopass"},"StripDebugInfoPass"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"StripDebugInfoPass")," removes debug information for instructions that will\nnever throw. As debug positions can correspond to multiple instructions, we need\nto check that none of the instructions will throw. Also, Redex won't strip the\nfirst piece of debug information in a function to preserve the accuracty of\nsampling profiles and ANR stack traces."),(0,s.mdx)("p",null,"The ",(0,s.mdx)("a",{parentName:"p",href:"/docs/getting_started/configuring"},"app's config file")," can direct ",(0,s.mdx)("inlineCode",{parentName:"p"},"StripDebugInfoPass")," removals at a\nmore granular level:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},'"StripDebugInfoPass" : {\n  "drop_all_dbg_info" : "0",\n  "drop_local_variables" : "1",\n  "drop_line_numbers" : "0",\n  "drop_src_files" : "0",\n  "use_allowlist" : "0",\n  "cls_allowlist" : [],\n  "method_allowlist" : [],\n  "drop_prologue_end" : "1",\n  "drop_epilogue_begin" : "1",\n  "drop_all_dbg_info_if_empty" : "1",\n  "drop_synth_aggressive" : "0",\n  "drop_line_numbers_preceeding_safe" : "1"\n},\n')),(0,s.mdx)("p",null,"Pass ordering dependencies:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("inlineCode",{parentName:"li"},"StripDebugInfoPass")," should be run early as removal of the debug info should\nmake other passes faster."),(0,s.mdx)("li",{parentName:"ul"},"Inlining complicates the flow graph for debug info. ",(0,s.mdx)("inlineCode",{parentName:"li"},"StripDebugInfoPass"),"\nshould be run before any inlining passes, and will not optiimize if inlining\nhas been performed.")))}u.isMDXComponent=!0}}]);